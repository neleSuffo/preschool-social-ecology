import sqlite3
import pandas as pd
from pathlib import Path
from typing import List, Dict, Tuple
import random
import logging
from constants import DataPaths, PersonClassification
from config import PersonConfig, DataConfig

logging.basicConfig(level=logging.INFO)

# --- GLOBAL CONSTANTS ---
DB_PATH = DataPaths.ANNO_DB_PATH
FRAME_BASE_PATH = DataPaths.IMAGES_INPUT_DIR
CATEGORY_IDS = PersonConfig.PERSON_CLS_TARGET_CLASS_IDS
CATEGORY_ID_TO_LABEL_DICT = PersonConfig.PERSON_CLS
TRAIN_SPLIT_RATIO = DataConfig.TRAIN_SPLIT_RATIO
OUTPUT_DIR = PersonClassification.PERSON_DATA_INPUT_DIR

def fetch_presence_per_frame(category_ids: List[int]) -> List[Tuple]:
    """
    Fetches all annotations for specified categories from the SQLite database.

    Parameters
    ----------
    category_ids (List[int])
        A list of integer IDs (e.g., [1, 2]) for the categories to fetch.

    Returns
    -------
    List[Tuple]
        A list of tuples, where each tuple contains (video_id, frame_id, file_name, category_id)
        for all detected instances of the specified categories.
    """
    conn = sqlite3.connect(DB_PATH)
    cursor = conn.cursor()

    placeholders = ", ".join("?" for _ in category_ids)
    query = f"""
    SELECT
        i.video_id,
        i.frame_id,
        i.file_name,
        a.category_id
    FROM annotations a
    JOIN images i
        ON a.image_id = i.frame_id AND a.video_id = i.video_id
    JOIN videos v
        ON a.video_id = v.id
    WHERE a.category_id IN ({placeholders})
      AND a.outside = 0
    ORDER BY i.video_id, i.frame_id
    """
    cursor.execute(query, category_ids)
    rows = cursor.fetchall()
    conn.close()

    logging.info(f"Fetched {len(rows)} annotation rows")
    return rows

def build_frame_level_labels(rows: List[Tuple], category_id_to_label: Dict[int, str]) -> pd.DataFrame:
    """
    Aggregates all detections in the same frame into binary presence labels.

    This function takes a list of annotation rows and converts them into a DataFrame
    where each row represents a unique video frame. The columns indicate the presence
    (1) or absence (0) of each specified category (e.g., 'adult', 'child') in that frame.

    Parameters
    ----------
    rows (List[Tuple])
        A list of tuples, where each tuple contains (video_id, frame_id, file_name
        , category_id) for each detected instance.
    category_id_to_label (Dict[int, str])
        A dictionary mapping integer category IDs to their string labels (e.g., {1: 'adult'}).

    Returns
    -------
        pd.DataFrame
            A DataFrame with columns ['video_id', 'frame_id', 'file_path'] and
            a column for each category name (e.g., 'adult', 'child') containing
            binary presence labels.
    """
    frame_dict = {}
    label_list = list(category_id_to_label.values())

    for video_id, frame_id, file_name, cat_id in rows:
        key = (video_id, frame_id, file_name)
        if key not in frame_dict:
            # Initialize with 0 for all categories
            frame_dict[key] = {label: 0 for label in label_list}
            
        # Set to 1 for the detected category
        if cat_id in category_id_to_label:
            label = category_id_to_label[cat_id]
            frame_dict[key][label] = 1

    # Convert the dictionary of frames to a DataFrame
    data = []
    for (video_id, frame_id, file_name), labels in frame_dict.items():
        row = {
            "video_id": video_id,
            "frame_id": frame_id,
            "file_path": str(FRAME_BASE_PATH / file_name),
            **labels
        }
        data.append(row)
    df = pd.DataFrame(data)
    return df

def split_by_child_id(df: pd.DataFrame, train_ratio: float = TRAIN_SPLIT_RATIO) -> Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]:
    """
    Splits the DataFrame into training, validation, and test sets based on unique child IDs.

    This method ensures that all frames belonging to the same child (video owner) are placed
    in the same split to prevent data leakage. The `child_id` is fetched from the database
    by joining on the `video_id`.

    Parameters
    ----------
    df (pd.DataFrame)
        The DataFrame of frame-level labels generated by `build_frame_level_labels`.
    train_ratio (float)
        The ratio of child IDs to be used for the training set.

    Returns
    -------
    Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]
        A tuple containing the training, validation, and test DataFrames.
    """
    val_ratio = (1 - train_ratio) / 2  # Split remaining equally between val and test
    
    conn = sqlite3.connect(DB_PATH)
    child_map = pd.read_sql_query("SELECT id as video_id, child_id FROM videos", conn)
    conn.close()
    df = df.merge(child_map, on="video_id", how="left")

    unique_child_ids = df["child_id"].unique().tolist()
    random.shuffle(unique_child_ids)

    n_total = len(unique_child_ids)
    n_train = int(train_ratio * n_total)
    n_val = int(val_ratio * n_total)

    train_ids = unique_child_ids[:n_train]
    val_ids = unique_child_ids[n_train:n_train + n_val]
    test_ids = unique_child_ids[n_train + n_val:]

    df_train = df[df["child_id"].isin(train_ids)].drop(columns=["child_id"])
    df_val = df[df["child_id"].isin(val_ids)].drop(columns=["child_id"])
    df_test = df[df["child_id"].isin(test_ids)].drop(columns=["child_id"])

    return df_train, df_val, df_test

if __name__ == "__main__":
    # Ensure the output directory exists
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)
    
    # The list is passed to the fetch function for the SQL query
    rows = fetch_presence_per_frame(CATEGORY_IDS)
    
    # The dictionary is passed to the build function for the DataFrame labels
    df = build_frame_level_labels(rows, CATEGORY_ID_TO_LABEL_DICT)
    
    df_train, df_val, df_test = split_by_child_id(df)

    df_train.to_csv(OUTPUT_DIR / "train.csv", index=False)
    df_val.to_csv(OUTPUT_DIR / "val.csv", index=False)
    df_test.to_csv(OUTPUT_DIR / "test.csv", index=False)

    logging.info(f"Generated CSV files at {OUTPUT_DIR}")
    logging.info(f"Train samples: {len(df_train)}")
    logging.info(f"Validation samples: {len(df_val)}")
    logging.info(f"Test samples: {len(df_test)}")